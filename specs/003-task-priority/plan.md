# План реализации: Приоритет задачи (редактируемый, сортировка, перетаскивание в группе)

**Ветка**: `003-task-priority` | **Дата**: 2026-02-17 | **Спецификация**: [spec.md](./spec.md)  
**Ввод**: Спецификация фичи из `specs/003-task-priority/spec.md`. Пользователь должен мочь перетаскивать задачи в списке только в рамках одного приоритета.

## Summary

Расширить существующее Todo App полем приоритета у задачи (Low, Medium, High): редактирование по клику через лёгкий выпадающий список (в стиле Jira), сортировка списка по приоритету (High → Medium → Low), визуальное выделение карточки еле уловимым цветом (High — красный, Medium — жёлтый, Low — синий), перетаскивание только внутри группы приоритета (drop в зоне другой группы недоступен). При смене приоритета задача помещается в конец новой группы. Стек без изменений: TypeScript, Vue 3, Vite, Pinia, localStorage; перетаскивание — vue-draggable-next с разделением по группам приоритета.

## Technical Context

**Language/Version**: TypeScript 5.x (как в проекте)  
**Primary Dependencies**: Vue 3, Vite, Pinia, vue-draggable-next, sortablejs (существующие)  
**Storage**: localStorage (тот же ключ `todo-app-tasks`; структура Task расширяется полем `priority`)  
**Testing**: Vitest, @vue/test-utils (unit); при необходимости E2E по контрактам 002  
**Target Platform**: браузер (десктоп и мобильный); мышь и тач  
**Project Type**: single (тот же репозиторий, расширение существующего приложения)  
**Performance Goals**: без деградации относительно текущего списка (~100 задач); отрисовка групп и цветов без заметной задержки  
**Constraints**: обратная совместимость данных (задачи без priority получают значение по умолчанию Medium); порядок внутри группы приоритета хранится и восстанавливается  
**Scale/Scope**: один пользователь, один список; три группы приоритета, порядок внутри группы — как в 001

## Проверка соответствия конституции

*Шлюз: пройти до фазы 0 (исследование). Повторить после фазы 1 (дизайн).*

Проверка по `.specify/memory/constitution.md`:

- **Чистый и поддерживаемый код**: Расширение типов и store в существующей структуре; именование (priority, setPriority, sortedTasksByPriority) соответствует соглашениям.
- **Тестируемость и код-ревью**: Изменения в store и компонентах тестируемы; ревью проверяет соответствие конституции.
- **Интуитивный и минималистичный UX**: Выпадающий список и цвет карточки — минимальные изменения; перетаскивание ограничено группой без лишнего UI.
- **Расширяемость**: Добавление приоритета не ломает существующие сценарии (добавление, toggle, перетаскивание в 001); при необходимости можно добавить четвёртый уровень приоритета позже.
- **Целостность данных**: Приоритет и order сохраняются в том же localStorage; при смене приоритета order пересчитывается для «конца группы»; миграция старых записей без priority — default Medium.
- **Устойчивость к ошибкам и валидация**: Значение priority только из множества { Low, Medium, High }; при загрузке невалидное значение — fallback на Medium.
- **Стандарты качества кода**: Соответствие структуре и стилю проекта (Vue 3, TypeScript, Pinia).

Отступлений нет; блок «Отслеживание сложности» пуст.

## Project Structure

### Documentation (эта фича)

```text
specs/003-task-priority/
├── plan.md              # Этот файл
├── research.md          # Фаза 0
├── data-model.md        # Фаза 1
├── quickstart.md        # Фаза 1
├── contracts/           # Фаза 1 (тип приоритета, расширение Task, API store)
└── tasks.md             # Фаза 2 (/speckit.tasks — создаётся отдельно)
```

### Source Code (корень репозитория)

Существующая структура сохраняется. Изменения:

```text
src/
├── types/
│   └── task.ts          # добавить priority: TaskPriority, константы приоритетов и цветов
├── stores/
│   └── todoStore.ts     # добавить priority в state/сериализацию; setPriority; sortedTasks по приоритету затем order; reorder в рамках группы
├── components/
│   ├── TaskItem.vue     # отобразить приоритет (выпадающий список по клику), цвет карточки по приоритету
│   └── TaskList.vue     # рендер по группам приоритета; отдельный VueDraggableNext на группу (drop только внутри группы)
└── ...
```

**Structure Decision**: Один фронтенд; расширяем модель Task и Pinia store. Список строится как группы по приоритету (High, Medium, Low); внутри каждой группы — свой экземпляр vue-draggable-next, чтобы drop между группами был недоступен. Цвет карточки задаётся CSS-классом или инлайн-стилем по значению priority (контракт цветов в data-model или constants).

## Complexity Tracking

Нарушений нет; таблица не заполняется.
