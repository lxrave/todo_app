# Исследование: Todo List (001-todo-list)

**Дата**: 2026-02-16  
**Цель**: Закрепить технологические решения и практики для реализации фичи.

---

## 1. Стек приложения (SPA, без бэкенда)

**Decision**: Vue 3 + TypeScript + Vite; состояние — Pinia; хранение — localStorage.

**Rationale**: В правилах проекта указаны Vue, TypeScript, Vite, Pinia. Для одного пользователя и одного устройства бэкенд не обязателен; localStorage обеспечивает сохранность после перезагрузки и соответствует FR-004.

**Alternatives considered**: React + Vite (не выбран — приоритет Vue в проекте); отдельный API + БД (отложено — избыточно для MVP).

---

## 2. Хранение данных (persistence)

**Decision**: Один ключ localStorage (например, `todo-app-tasks`); значение — JSON-массив объектов задач с полями id, text, completed, order. Чтение при старте приложения; запись при каждом изменении списка (add, toggle, reorder).

**Rationale**: Простота, отсутствие сервера, соответствие конституции (целостность данных). Риск потери при очистке хранилища пользователем принимается для MVP.

**Alternatives considered**: IndexedDB (сложнее, не нужен для объёма до сотен задач); серверное API (выходит за рамки текущей спецификации).

---

## 3. Перетаскивание (drag-and-drop)

**Decision**: Использовать библиотеку, совместимую с Vue 3 и поддерживающую и мышь, и тач (например, vuedraggable на основе Sortable.js, или VueDraggable Next). Требование: доступность с клавиатуры не обязательна в рамках текущей спецификации, но не должна ломаться.

**Rationale**: Нативная реализация DnD для тач и мыши трудоёмка и легко даёт баги; проверенные библиотеки ускоряют разработку и соответствуют FR-005.

**Alternatives considered**: Только мышь (отклонено — в спецификации указан тап); кастомная реализация (отклонено — выше риск багов и затраты времени).

**Реактивность списка**: Чтобы перетаскивание (vue-draggable-next) не ломало появление новых задач, в TaskList используется мутабельный ref `list`, синхронизируемый с `store.tasks` через watch(store.tasks, …, { deep: true, flush: 'sync' }). В шаблоне в draggable передаётся именно `list`; при @end вызывается store.reorderTasks, store обновляется и watch снова синхронизирует list. Источник правды — store.tasks.

---

## 4. Валидация и обратная связь (пустая задача)

**Decision**: Не создавать задачу с пустым или состоящим только из пробелов текстом. В UI: кнопка «Добавить» неактивна при пустом поле и/или показ короткого сообщения при отправке пустого значения (если форма допускает отправку).

**Rationale**: Соответствует FR-006 и конституции (устойчивость к ошибкам, валидация). Trim при проверке — разумный стандарт.

**Alternatives considered**: Создавать задачу с пустым текстом (отклонено — противоречит спецификации).

---

## 5. Тестирование

**Decision**: Vitest + @vue/test-utils для юнит-тестов компонентов и Pinia-хранилища. E2E — опционально на следующем этапе (Playwright или Cypress).

**Rationale**: Vite-экосистема и Vue 3 хорошо стыкуются с Vitest; конституция требует тестируемости.

**Alternatives considered**: Jest (работает с Vue, но Vitest предпочтительнее для Vite); только ручная проверка (отклонено).

---

## 6. Идентификация задач и порядок

**Decision**: У каждой задачи уникальный id (например, nanoid или crypto.randomUUID). Поле order — число (индекс в отображаемом списке) или порядок определяется позицией в массиве после сортировки по order. При перетаскивании пересчитывать order у затронутых задач и сохранять в localStorage.

**Rationale**: Стабильная идентификация для Vue (key) и для обновлений; порядок явно хранится и восстанавливается (FR-004, FR-005).

**Alternatives considered**: Только порядок в массиве без order (приемлемо для простого списка; явный order упрощает персистенс и отладку).
